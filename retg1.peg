
### Begin grammar definitions

parse_program <-
  _ declare_program _ declare_run _ eof {
    FILE* asmFile = NULL;

    asmFile = fopen(asmFileName, "w");
    if( asmFile == NULL ) {
      printf( "Error creating assembler file '%s'\n", asmFileName );
      exit(3);
    }

    fprintf( asmFile,
      "\n"
      "  BITS 32\n"
      "\n"
      "%s\n"
      "%s\n"
      "%s\n"
      "%s\n"
      "%s\n",
      auxil->asmgen.dllImports ? auxil->asmgen.dllImports : "",
      auxil->asmgen.codeSegment ? auxil->asmgen.codeSegment : "",
      auxil->asmgen.dataSegment ? auxil->asmgen.dataSegment : "",
      auxil->asmgen.stackSegment ? auxil->asmgen.stackSegment : "",
      auxil->asmgen.bssSegment ? auxil->asmgen.bssSegment : ""
    );

    fclose( asmFile );
    asmFile = NULL;
  }

# program IDENT
declare_program <-
  'program' _ <ident> {
    auxil->asmgen.dllImports = sdsnew(
      "  extern ExitProcess\n"
      "  import ExitProcess kernel32.dll\n"
      "\n"
    );

    auxil->asmgen.codeSegment = sdsnew(
      "segment .code use32\n"
      "\n"
    );

    auxil->asmgen.dataSegment = sdsnew(
      "segment .data use32\n"
      "\n"
    );

    auxil->asmgen.stackSegment = sdsnew(
      "segment .stack use32\n"
      "\n"
    );

    auxil->asmgen.bssSegment = sdsnew(
      "segment .bss use32\n"
      "\n"
    );
  }

# top level declarations
#top_level_declarations <- _

# run block declarations
declare_run <-
  declare_run_begin
  _
  declare_run_end

declare_run_begin <-
  'run' {
    auxil->asmgen.codeSegment = sdscat(
      auxil->asmgen.codeSegment,
      "\n"
      "..start:\n"
      "  push    ebp\n"
      "  mov     ebp, esp\n"
      "\n"
    );
  }

declare_run_end <-
  'end' {
    auxil->asmgen.codeSegment = sdscat(
      auxil->asmgen.codeSegment,
      "  mov     esp, ebp\n"
      "  pop     ebp\n"
      "\n"
      "  push    dword 0\n"
      "  call    [ExitProcess]\n"
      "\n"
    );
  }

# qualified_ident rule adapted from:
# https://stackoverflow.com/questions/51397025/peg-parsing-declarations-with-arbitrary-number-of-qualifiers
#qualified_ident <-
#  (qualifier _ '.')* _ <ident> {
#    printf( "IDENT[%s]\n", $1 );
#  }
#
#qualifier <-
#  _ <ident> {
#    printf( "QUALIFIER[%s]\n", $1 );
#  }

ident <- [_a-zA-Z][_a-zA-Z0-9]*

_ <- (space / eol / single_line_comment / multi_line_comment)*

single_line_comment <-
  '//' (!eol !eof .)* (eol / eof)

# multi_line_comment rule adapted from:
# https://stackoverflow.com/questions/28419972/how-do-you-parse-nested-comments-in-pegjs
multi_line_comment <-
  '/*' ((!'/*' !'*/' .) / multi_line_comment)* '*/'

space <- [ \t]

eol <- '\r' / '\n' / '\r\n'

eof <- !.

### End grammar definitions

%auxil "ParseState* "

%earlyheader {
}

%earlysource {
}

%earlycommon {
}

%header {
  #include "3rdparty/sds/sdsalloc.h"
  #include "3rdparty/sds/sds.h"

  #include "3rdparty/avl_tree/avl_tree.h"

  #ifndef _MAX_PATH
  // https://learn.microsoft.com/en-us/windows/win32/fileio/maximum-file-path-limitation
  #define _MAX_PATH 260
  #endif

  #ifndef _MAX_DRIVE
  // https://learn.microsoft.com/en-us/previous-versions/8e46eyt7(v=vs.140)
  #define _MAX_DRIVE 3
  #endif

  #ifndef _MAX_DIR
  // https://learn.microsoft.com/en-us/previous-versions/8e46eyt7(v=vs.140)
  #define _MAX_DIR 256
  #endif

  #ifndef _MAX_FNAME
  // https://learn.microsoft.com/en-us/previous-versions/8e46eyt7(v=vs.140)
  #define _MAX_FNAME 256
  #endif

  #ifndef _MAX_EXT
  // https://learn.microsoft.com/en-us/previous-versions/8e46eyt7(v=vs.140)
  #define _MAX_EXT 256
  #endif

  /// Begin symbol table definitions
  typedef struct SymbolTable {
    struct avl_tree_node node;
  } SymbolTable;
  /// End symbol table definitions

  /// Begin parse state auxil declarations
  typedef struct SourceFile {
    FILE* handle;

    unsigned line;
    unsigned column;

    unsigned nextLine;
    unsigned nextColumn;

    char ch;
    char nextch;
  } SourceFile;

  typedef struct AsmFile {
    sds dllImports;
    sds codeSegment;
    sds dataSegment;
    sds stackSegment;
    sds bssSegment;
  } AsmFile;

  typedef struct ParseState {
    SourceFile source;
    AsmFile asmgen;
    SymbolTable symtab;
  } ParseState;
  // End parse state auxil declarations
}

%source {
  #include "3rdparty/sds/sds.c"

  #include "3rdparty/avl_tree/avl_tree.c"

  ParseState parseState = {};

  sds retFileName = NULL;
  sds asmFileName = NULL;
  sds objFileName = NULL;
  sds exeFileName = NULL;

  // begin strnlen copied from packcc.c source file, as a workaround for TinyCC
  #ifdef __TINYC__
  static size_t strnlen(const char *str, size_t maxlen) {
    size_t i;
    for( i = 0; (i < maxlen) && str[i]; i++ ) {
    };
    return i;
  }
  #endif
  // end strnlen

/*
  static const char *dbg_str[] = { "Evaluating rule", "Matched rule", "Abandoning rule" };
  #define PCC_DEBUG(event, rule, level, pos, buffer, length) \
      fprintf(stderr, "%*s%s %s @%d [%.*s]\n", level * 2, "", dbg_str[event], rule, pos, length, buffer);
*/

  /// Begin PCC_ERROR override
  #define PCC_ERROR(auxil) ParseError(auxil)
  static void ParseError( ParseState* auxil ) {
    if( auxil ) {
      fprintf(stderr, "Parse Error[L%u,C%u]\n", auxil->source.line, auxil->source.column);
    } else {
      fprintf(stderr, "Internal Parse Error\n");
    }
    exit(1);
  }
  /// End PCC_ERROR override

  /// Begin PCC_GETCHAR override
  #define PCC_GETCHAR(auxil) ReadChar(auxil);
  int ReadChar( ParseState* auxil ) {
    if( auxil && auxil->source.handle ) {
      auxil->source.line = auxil->source.nextLine;
      auxil->source.column = auxil->source.nextColumn;

      auxil->source.ch = auxil->source.nextch;
      auxil->source.nextch = fgetc(auxil->source.handle);

      if( auxil->source.nextch != EOF ) {
        if( auxil->source.ch == 13 ) {
          auxil->source.ch = 10;
          if( auxil->source.nextch == 10 ) {
            auxil->source.nextch = fgetc(auxil->source.handle);
          }
        }

        if( auxil->source.ch == 10 ) {
          auxil->source.nextLine++;
          auxil->source.nextColumn = 0;
        }

        auxil->source.nextColumn++;
      }
    }

    return auxil->source.ch;
  }
  // End PCC_GETCHAR override

  void Error( const char* errorMessage ) {
    fprintf( stderr, "Error: %s\n", errorMessage ); // stderr temporary
    exit(2);
  }

  void SyntaxError( unsigned line, unsigned column, const char* errorMessage ) {
    fprintf( stderr, "Syntax Error[L%u,C%u]: %s\n", line, column, errorMessage ); // stderr temporary
    exit(3);
  }
}

%common {
}

%%

/*
 *  System helper implementation
 */

#include <process.h>

int RunProgram( const char* programName, char* const cmdArgs[], int* exitCode ) {
  int runResult = 0;

  runResult = spawnvp(_P_WAIT, programName, cmdArgs);

  if( runResult != -1 ) {
    *exitCode = runResult;
    return -1;
  }

  return 0;
}

/// Open source file - begin
void OpenSourceFile( const char* sourceFileName ) {
  if( !(sourceFileName && (*sourceFileName)) ) { return; }

  parseState.source.handle = fopen(sourceFileName, "rb");
  if( parseState.source.handle == NULL ) {
    printf( "Error opening source file '%s'\n", sourceFileName );
    exit(2);
  }

  parseState.source.ch = EOF;
  parseState.source.nextch = EOF;

  ReadChar( &parseState );

  parseState.source.line = 1;
  parseState.source.column = 1;
  parseState.source.nextLine = 1;
  parseState.source.nextColumn = 1;
}
/// Open source file - end

/// Close source file - begin
void CloseSourceFile() {
  if( parseState.source.handle ) {
    fclose( parseState.source.handle );
    parseState.source.handle = NULL;
  }
}
/// Close source file - end

void ShowBanner() {
  printf(
    "\n"
    "Retineo G1 Copyright 1993 - 2023 Orlando Llanes\n"
    "\n"
  );
}

void ShowUsage() {
  printf(
    "Usage: retg1 source[.ret] [binary[.ext]]\n"
    "\n"
  );
  exit(1);
}

void ParseOptions( int argc, char** argv ) {
  char* sourceArg = NULL;
  char* binaryArg = NULL;

  char sourceDrive[_MAX_DRIVE] = {0};
  char sourceDir[_MAX_DIR] = {0};
  char sourceName[_MAX_FNAME] = {0};
  char sourceExt[_MAX_EXT] = {0};

  char binaryDrive[_MAX_DRIVE] = {0};
  char binaryDir[_MAX_DIR] = {0};
  char binaryName[_MAX_FNAME] = {0};
  char binaryExt[_MAX_EXT] = {0};

  switch( argc ) {
  case 3: // retg1 source[.ret] [binary[.exe]]
    binaryArg = argv[2];

  case 2: // retg1 source[.ret]
    sourceArg = argv[1];
    break;

  default:
    ShowUsage();
  }

  if( sourceArg ) {
    _splitpath(sourceArg, sourceDrive, sourceDir, sourceName, sourceExt);
    if( (*sourceExt) == 0 ) {
      strcpy( sourceExt, ".ret" );
    }

    retFileName = sdscatfmt(sdsempty(), "%s%s%s%s",
        sourceDrive, sourceDir, sourceName, sourceExt);

    _splitpath(sourceArg, binaryDrive, binaryDir, binaryName, binaryExt);
    strcpy( binaryExt, ".exe" );
  }

  if( binaryArg ) {
    _splitpath(binaryArg, binaryDrive, binaryDir, binaryName, binaryExt);

    if( (*binaryDrive) == 0 ) {
      strcpy( binaryDrive, sourceDrive );
    }

    if( (*binaryDir) == 0 ) {
      strcpy( binaryDir, sourceDir );
    }

    if( (*binaryName) == 0 ) {
      strcpy( binaryName, sourceName );
    }

    if( (*binaryExt) == 0 ) {
      strcpy( binaryExt, ".exe" );
    }
  }

  asmFileName = sdscatfmt(sdsempty(), "%s%s%s%s",
      binaryDrive, binaryDir, binaryName, ".asm");

  objFileName = sdscatfmt(sdsempty(), "%s%s%s%s",
      binaryDrive, binaryDir, binaryName, ".obj");

  exeFileName = sdscatfmt(sdsempty(), "%s%s%s%s",
      binaryDrive, binaryDir, binaryName, binaryExt);
}

void Cleanup() {
  CloseSourceFile();

  sdsfree( retFileName );
  sdsfree( asmFileName );
  sdsfree( objFileName );
  sdsfree( exeFileName );
}

int main( int argc, char* argv[] ) {
  atexit( Cleanup );

  pcc_context_t *ctx = pcc_create(&parseState);

  ShowBanner();

  ParseOptions( argc, argv );

  OpenSourceFile( retFileName );

  while( pcc_parse(ctx, NULL) ) {
  }

  printf( "Building '%s'...\n\n", asmFileName );

  char* nasmOptions[] = {
    " ",
    "-fobj",
    asmFileName,
    NULL
  };
  int nasmResult = 0;
  if( (RunProgram("3rdparty/nasm/nasm.exe", nasmOptions, &nasmResult) == 0) ||
      nasmResult ) {
    Error( "Error attempting to run 3rdparty/nasm/nasm.exe" );
  }

  printf( "Linking '%s'...\n\n", exeFileName );

  char* alinkOptions[] = {
    " ",
    "-p",
    "-subsys console",
    "-oPE",
    objFileName,
    NULL
  };
  int alinkResult = 0;
  if( (RunProgram("3rdparty/alink/alink.exe", alinkOptions, &alinkResult) == 0) ||
      alinkResult ) {
    Error( "Error attempting to run 3rdparty/alink/alink.exe" );
  }
  printf( "\n" );

  Cleanup();

  pcc_destroy( ctx );

  return 0;
}
