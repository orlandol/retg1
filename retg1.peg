
### Begin grammar definitions

source <-
  _ declare_program _ declare_run _ eof {
    printf(
      "%s%s%s%s%s",
      auxil->asmgen.dllImports,
      auxil->asmgen.codeSegment,
      auxil->asmgen.dataSegment,
      auxil->asmgen.stackSegment,
      auxil->asmgen.bssSegment
    );

    printf(
      "\n"
      "segment .data use32\n"
      "\n"
      "segment .stack use32\n"
      "\n"
      "segment .bss use32\n"
      "\n"
    );
  }

# program IDENT
declare_program <-
  'program' _ <ident> {
    printf( "; PROGRAM[%s]\n", $1 );
    printf(
      "\n"
      "  CPU 386\n"
      "\n"
      "  BITS 32\n"
      "\n"
      "  extern ExitProcess\n"
      "  import ExitProcess kernel32.dll\n"
      "\n"
      "segment .code use32\n"
      "\n"
    );
  }

# top level declarations
#top_level_declarations <- _

# run block declarations
declare_run <-
  declare_run_begin
  _
  declare_run_end

declare_run_begin <-
  'run' {
    printf( "; RUN_BEGIN\n" );
    printf(
      "\n"
      "..start:\n"
      "  push    ebp\n"
      "  mov     ebp, esp\n"
      "\n"
    );
  }

declare_run_end <-
  'end' {
    printf( "; RUN_END\n" );
    printf(
      "  mov     esp, ebp\n"
      "  pop     ebp\n"
      "\n"
      "  push    dword 0\n"
      "  call    [ExitProcess]\n"
      "\n"
    );
  }

# qualified_ident rule adapted from:
# https://stackoverflow.com/questions/51397025/peg-parsing-declarations-with-arbitrary-number-of-qualifiers
#qualified_ident <-
#  (qualifier _ '.')* _ <ident> {
#    printf( "IDENT[%s]\n", $1 );
#  }
#
#qualifier <-
#  _ <ident> {
#    printf( "QUALIFIER[%s]\n", $1 );
#  }

ident <- [_a-zA-Z][_a-zA-Z0-9]*

_ <- (space / eol / single_line_comment / multi_line_comment)*

single_line_comment <-
  '//' (!eol !eof .)* (eol / eof)

# multi_line_comment rule adapted from:
# https://stackoverflow.com/questions/28419972/how-do-you-parse-nested-comments-in-pegjs
multi_line_comment <-
  '/*' ((!'/*' !'*/' .) / multi_line_comment)* '*/'

space <- [ \t]

eol <- '\r' / '\n' / '\r\n'

eof <- !.

### End grammar definitions

%auxil "ParseState* "

%earlyheader {
}

%earlysource {
}

%earlycommon {
}

%header {
  #include "3rdparty/sds/sds.h"

  /// Begin parse state auxil declarations
  typedef struct SourceFile {
    FILE* handle;

    unsigned line;
    unsigned column;

    unsigned nextLine;
    unsigned nextColumn;

    char ch;
    char nextch;
  } SourceFile;

  typedef struct AsmFile {
    sds dllImports;
    sds codeSegment;
    sds dataSegment;
    sds stackSegment;
    sds bssSegment;
  } AsmFile;

  typedef struct ParseState {
    SourceFile source;
    AsmFile asmgen;
  } ParseState;
  // End parse state auxil declarations
}

%source {
  #include "3rdparty/sds/sds.c"

  ParseState parseState = {};

  // begin strnlen copied from packcc.c source file, as a workaround for TinyCC
  #ifdef __TINYC__
  static size_t strnlen(const char *str, size_t maxlen) {
    size_t i;
    for( i = 0; (i < maxlen) && str[i]; i++ ) {
    };
    return i;
  }
  #endif
  // end strnlen

/*
  static const char *dbg_str[] = { "Evaluating rule", "Matched rule", "Abandoning rule" };
  #define PCC_DEBUG(event, rule, level, pos, buffer, length) \
      fprintf(stderr, "%*s%s %s @%d [%.*s]\n", level * 2, "", dbg_str[event], rule, pos, length, buffer);
*/

  /// Begin PCC_ERROR override
  #define PCC_ERROR(auxil) ParseError(auxil)
  static void ParseError( ParseState* auxil ) {
    if( auxil ) {
      fprintf(stderr, "Parse Error[L%u,C%u]\n", auxil->source.line, auxil->source.column);
    } else {
      fprintf(stderr, "Internal Parse Error\n");
    }
    exit(1);
  }
  /// End PCC_ERROR override

  /// Begin PCC_GETCHAR override
  #define PCC_GETCHAR(auxil) ReadChar(auxil);
  int ReadChar( ParseState* auxil ) {
    if( auxil && auxil->source.handle ) {
      auxil->source.line = auxil->source.nextLine;
      auxil->source.column = auxil->source.nextColumn;

      auxil->source.ch = auxil->source.nextch;
      auxil->source.nextch = fgetc(auxil->source.handle);

      if( auxil->source.nextch != EOF ) {
        if( auxil->source.ch == 13 ) {
          auxil->source.ch = 10;
          if( auxil->source.nextch == 10 ) {
            auxil->source.nextch = fgetc(auxil->source.handle);
          }
        }

        if( auxil->source.ch == 10 ) {
          auxil->source.nextLine++;
          auxil->source.nextColumn = 0;
        }

        auxil->source.nextColumn++;
      }
    }
    return auxil->source.ch;
  }
  // End PCC_GETCHAR override
}

%common {
}

%%

/*
 *  System helper implementation
 */

#include <process.h>

int RunProgram( const char* programName, char* const cmdArgs[], int* exitCode ) {
  int runResult = 0;

  runResult = spawnvp(_P_WAIT, programName, cmdArgs);

  if( runResult != -1 ) {
    *exitCode = runResult;
    return -1;
  }

  return 0;
}

/// Open source file - begin
void OpenSourceFile( const char* sourceFileName ) {
  if( !(sourceFileName && (*sourceFileName)) ) { return; }

  parseState.source.handle = fopen(sourceFileName, "rb");
  if( parseState.source.handle == NULL ) {
    printf( "Error opening source file '%s'\n", sourceFileName );
    exit(2);
  }

  parseState.source.ch = EOF;
  parseState.source.nextch = EOF;

  ReadChar( &parseState );

  parseState.source.line = 1;
  parseState.source.column = 1;
  parseState.source.nextLine = 1;
  parseState.source.nextColumn = 1;
}
/// Open source file - end

/// Close source file - begin
void CloseSourceFile() {
  if( parseState.source.handle ) {
    fclose( parseState.source.handle );
    parseState.source.handle = NULL;
  }
}
/// Close source file - end

void Cleanup() {
  CloseSourceFile();
}

int main( int argc, char* argv[] ) {
  atexit( Cleanup );

  pcc_context_t *ctx = pcc_create(&parseState);

  fprintf( stderr,
    "\n"
    "Retineo G1 Copyright 1993-2023 Orlando Llanes\n"
    "\n"
  );

  if( argc != 3 ) {
    fprintf( stderr, "Usage: retg1 source.ret binary.exe\n" );
    exit(1);
  }

  OpenSourceFile( argv[1] );

  while( pcc_parse(ctx, NULL) ) {
  }

  Cleanup();

  pcc_destroy( ctx );

  /* Build assembler source */
/*
  printf( "\nBuilding '%s'...\n", rstrtext(asmFileName) );

  char* nasmOptions[] = {
    " -fobj",
    rstrtext(asmFileName),
    NULL
  };
  int nasmResult = 0;
  if( (RunProgram("3rdparty/nasm/nasm.exe", nasmOptions, &nasmResult) == false) ||
      nasmResult ) {
    Error( unableToRun, "3rdparty/nasm/nasm.exe" );
  }
*/

  /* Link executable */
/*
  printf( "\nLinking '%s'...\n", rstrtext(exeFileName) );

  char* alinkOptions[] = {
    " -c",
    "-oPE",
    "-subsys console",
    rstrtext(objFileName),
    NULL
  };
  int alinkResult = 0;
  if( (RunProgram("3rdparty/alink/alink.exe", alinkOptions, &alinkResult) == false) ||
      alinkResult ) {
    Error( unableToRun, "3rdparty/alink/alink.exe" );
  }
*/

  return 0;
}
